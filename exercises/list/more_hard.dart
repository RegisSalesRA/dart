/* #### 1 ### */
// Lista de números
List<int> numeros1 = [1, 2, 3, 4, 5, 6];
// Implementar um algoritmo que encontre a **subsequência contígua de maior soma** na lista (Kadane’s Algorithm).

/* #### 2 ### */
// Lista de palavras
List<String> palavras = ['banana', 'ananas', 'abacate', 'manga'];
// Criar uma função que encontre o **maior prefixo comum** entre todas as palavras da lista.

/* #### 3 ### */
// Lista de números
List<int> numeros2 = [1, 2, 3, 4, 5, 6];
// Criar uma função que retorne todas as **sublistas não vazias possíveis** (powerset) da lista.

/* #### 4 ### */
// Lista de números
List<int> numeros3 = [2, 4, 1, 3, 6];
// Implementar um algoritmo que determine se a lista pode ser ordenada em ordem crescente com, no máximo, **uma troca de elementos**.

/* #### 5 ### */
// Lista de números
List<int> numeros4 = [1, 2, 3, 4, 5];
// Implementar uma função que encontre o **n-ésimo número da sequência de Fibonacci** de forma otimizada, utilizando memoização ou tabulação.

/* #### 6 ### */
// Lista de palavras
List<String> palavras2 = ['casa', 'programar', 'sol', 'escola'];
// Criar uma função que agrupe as palavras da lista que são **anágramas** entre si (exemplo: ['sol', 'los']).

/* #### 7 ### */
// Lista de números
List<int> numeros5 = [4, 8, 15, 16, 23, 42];
// Criar um algoritmo para encontrar os **k maiores números** na lista de forma eficiente (exemplo: heap sort ou quickselect).

/* #### 8 ### */
// Lista de números
List<int> numeros6 = [1, 2, 3, 4, 5];
// Implementar uma função que calcule o **produto cartesiano** entre a lista e ela mesma, retornando todas as combinações possíveis (exemplo: [(1,1), (1,2), ...]).

/* #### 9 ### */
// Lista de números
List<int> numeros7 = [2, 3, 5, 7, 11, 13];
// Implementar um algoritmo que determine todos os **subconjuntos cuja soma seja igual a um valor-alvo** fornecido (Subset Sum Problem).

/* #### 10 ### */
// Lista de palavras
List<String> palavras3 = ['programar', 'é', 'muito', 'divertido'];
// Criar uma função que implemente um **autocorretor** básico, comparando as palavras da lista com um dicionário fornecido e corrigindo palavras que tenham uma distância de edição (Levenshtein distance) menor ou igual a 2.
